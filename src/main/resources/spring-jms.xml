<?xml version="1.0" encoding="UTF-8"?>
<!-- 查找最新的schemaLocation 访问 http://www.springframework.org/schema/ -->
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:amq="http://activemq.apache.org/schema/core"
	   xmlns:jms="http://www.springframework.org/schema/jms"
	   xsi:schemaLocation="http://www.springframework.org/schema/beans
		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
		http://www.springframework.org/schema/context
		http://www.springframework.org/schema/context/spring-context-3.2.xsd
		http://www.springframework.org/schema/jms
		http://www.springframework.org/schema/jms/spring-jms-4.1.xsd
		http://activemq.apache.org/schema/core
		http://activemq.apache.org/schema/core/activemq-core-5.8.0.xsd">

	<!--

		在Spring中使用JMS发送和接受消息
		，这里使用ActiveMQ作为消息代理

		首先第一步，配置JMS连接工厂，让它知道如何连接到ActiveMQ
	-->
	<bean id="connectionFactory" class="org.apache.activemq.spring.ActiveMQConnectionFactory">
		<!--默认情况下，ActiveMQConnectionFactory会假设ActiveMQ代理监听localhost的61616端口-->
		<!--但在生产环境下，ActiveMQ可能会在不同的主机和端口上，如果是这样，可以使用BrokerURL属性来指定代理的URL-->
		<property name="brokerURL" value="tcp://localhost:61616"/>

		<!--声明可以解析序列化的对象，不配置这个的话，客户端得到消息后，会报Serializable class not available to broker错误-->
		<property name="trustedPackages">
			<list>
				<value>com.khh.entity.User</value>
			</list>
		</property>
		<!--也可以这样声明，所有对象都可以解析-->
		<property name="trustAllPackages" value="true"/>
	</bean>


	<!--
		声明ActiveMQ消息目的地
		目的地可以是一个队列，也可以是一个主题
	-->
	<!--声明定义一个ActiveMQ队列-->
	<bean id="queue" class="org.apache.activemq.command.ActiveMQQueue">
		<constructor-arg value="user.queue" />
	</bean>
	<!--声明定义一个ActiveMQ主题-->
	<bean id="topic" class="org.apache.activemq.command.ActiveMQTopic">
		<constructor-arg value="user.topic"/>
	</bean>

	<!--
		声明JmsTemplate，方便开发
	-->
	<bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate">
		<constructor-arg ref="connectionFactory"/>
		<!--设置默认的接收消息的目的地，不用每次调用jmsOperations.send时设置目的地,
		如果设置的名称不存在，那么将会创建一个新的目的地，通常会是队列-->
		<property name="defaultDestinationName" value="user.queue"/>
		<!--配置默认的消息转换器,这里配了一个json转换器，把发送出去的对象全部转换成json类型消息-->
		<property name="messageConverter" ref="jsonMessageConverter"/>
	</bean>

	<bean id="jsonMessageConverter" class="org.springframework.jms.support.converter.MappingJackson2MessageConverter"/>


	<!--  /////////////////////////////////////////以上配置适用于demo1///////////////////////////////////////////////////////////////////////////      -->

	<!--
		声明一个Message Driven POJO(MDP)
	-->
	<bean id="exampleListener" class="com.khh.demo2_pojo.listener.ExampleListener"/>

	<!--
		装配一个消息监听容器,当配置了这个容器之后，就会自动监听到destination指定的路径，一旦有消息发送过来，
		就会被ExampleListener截取到，并且由ExampleListener处理对应的消息
	-->
	<bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer">
		<property name="connectionFactory" ref="connectionFactory"/>
		<property name="destination" ref="queue"/>
		<property name="messageListener" ref="exampleListener"/>
	</bean>


</beans>
